# -*- mode: ruby -*-
# vi: set ft=ruby :

### SET THIS TO -test (DASH TEST) TO ENABLE TEST MODE ###
TEST=""
INTERACTIVE = true
PURPOSE = "k8s-cluster#{TEST}"
LIFECYCLE = "int#{TEST}"
DOMAIN = "anytown.usa"

IMAGE = "ubuntu/bionic64"
PROVIDER = "virtualbox"
ROOT_KEY_SCRIPT = "root_key.sh"
VAGRANT_KEY_SCRIPT = "vagrant_key.sh"

NODE_SCRIPT = "node#{TEST}.sh"
MASTER_SCRIPT = "master#{TEST}.sh"
CONTROLER_SCRIPT = "controller#{TEST}.sh"
HOSTNAME_SUFFIX = "#{PURPOSE}.#{LIFECYCLE}.#{DOMAIN}"

CONTROLER = "controller"
VM_NAME_CONTROLER = "#{PURPOSE}_#{LIFECYCLE}_#{CONTROLER}"

MASTER = "master"
VM_NAME_MASTER = "#{PURPOSE}_#{LIFECYCLE}_#{MASTER}"

NODE = "node"
VM_NAME_NODE = "#{PURPOSE}_#{LIFECYCLE}_#{NODE}"

VAGRANTFILE_API_VERSION = "2"

### START Vagrant.configure ###
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

IPLIST = ""
NAMELIST = ""
FQDN = ""
ETC_HOSTS = ""
POD_NETWORK = "192.168.0.0"
NETMASK = 24

### HARD CODED ON PURPOSE -bindia 20201207
POD_NODE_CT = 3
MSTR_NODE_CT = 1
CTLR_NODE_CT = 1

ctlr_ip_pool = ['192.168.0.10']
ctlr_nm_pool = ["#{CONTROLER}"]
mstr_ip_pool = ['192.168.0.20']
mstr_nm_pool = ["#{MASTER}"]

admin_ip_pool = ctlr_ip_pool + mstr_ip_pool
admin_nm_pool = ctlr_nm_pool + mstr_nm_pool

pod_ip_pool = ['192.168.0.2','192.168.0.3','192.168.0.4','192.168.0.5','192.168.0.6','192.168.0.7','192.168.0.8','192.168.0.9']
pod_nm_pool = ['node1',      'node2',      'node3',      'node4',      'node5',      'node6',      'node7',      'node8',     ]

host_ip_pool = admin_ip_pool# + pod_ip_pool
host_nm_pool = admin_nm_pool# + pod_nm_pool

for i in (0..POD_NODE_CT - 1) do
   "#{host_ip_pool.append(pod_ip_pool[i])}"
   "#{host_nm_pool.append(pod_nm_pool[i])}"
end

host_ip_pool.each do |ip| IPLIST+="#{ip} " end
for i in (0..MSTR_NODE_CT+MSTR_NODE_CT+POD_NODE_CT - 1) do
   NAMELIST += "#{host_nm_pool[i]} "
   FQDN += "#{host_nm_pool[i]}.#{PURPOSE}.#{LIFECYCLE}.#{DOMAIN} "
   ETC_HOSTS += "\n#{host_ip_pool[i]} #{host_nm_pool[i]}.#{PURPOSE}.#{LIFECYCLE}.#{DOMAIN} #{host_nm_pool[i]}"
end

# WRITES:   /bin/run-ssh
$BIN_RUNSSH = "echo #{MSG} Running: \\$BIN_RUNSSH
echo '#!/bin/bash
if [ $# -gt 0 ]; then for ip in #{IPLIST}; do ssh root@${ip} \"${1}\"; done;
else echo \" Usage: Need argument to send\"; fi
' > /bin/run-ssh
chmod 774 /bin/run-ssh
"

# ADDS:     /etc/hosts
$ETC_HOSTS = "echo #{MSG} Running: \\$ETC_HOSTS
echo -e '#{ETC_HOSTS}' >> /etc/hosts
"

# WRITES:   /etc/init/synchosts.sh
$ETC_INIT_SYNCHOSTS = <<EOF
echo #{MSG} Running: \\$ETC_INIT_SYNCHOSTS
if [ ! -d /etc/init ]; then mkdir /etc/init && chmod 755 ${_}; fi
echo '#!/bin/bash
> /root/.ssh/known_hosts && chmod 600 /root/.ssh/known_hosts
for ip in #{IPLIST}; do
   ssh-keyscan -H ${ip} >> /root/.ssh/known_hosts; done
for nm in #{NAMELIST}; do
   ssh-keyscan -H ${nm} >> /root/.ssh/known_hosts; done
for nm in #{FQDN}; do
   ssh-keyscan -H ${nm} >> /root/.ssh/known_hosts; done
cp -f /root/.ssh/known_hosts /home/vagrant/.ssh/known_hosts \
   && chown vagrant:vagrant /home/vagrant/.ssh/known_hosts \
   && chmod 600 /home/vagrant/.ssh/known_hosts
' > /etc/init/synchosts.sh \
&& chmod 755 /etc/init/synchosts.sh
EOF

# WRITES:   /etc/init.d/ntpsync.sh
# LINKS:    /etc/rc3.d/S01ntpsync
$ETC_INITD_NTPSYNC = <<EOF
echo #{MSG} Running: \\$ETC_INITD_NTPSYNC
echo '#!/bin/bash

if ! ntpstat > /dev/null 2>&1
   then service ntp stop && ntpdate time.nist.gov && service ntp start
   ntp_tries=15 && ntp_delay_seconds=2 && i=0
   while ! ntpstat
     do sleep ${ntp_delay_seconds} && i=`expr ${i} + 1`
     if [ ${i} -ge ${ntp_tries} ]
       then yellow "NTP:" && echo bailing && break
     fi
   done
fi' > /etc/init.d/ntpsync.sh \
   && chmod 755 /etc/init.d/ntpsync.sh \
   && ln -sfn /etc/init.d/ntpsync.sh /etc/rc3.d/S01ntpsync
EOF

$ETC_BASHRC = <<EOF
echo #{MSG} Running: \\$ETC_BASHRC
#{BASHRC}  >> /etc/bash.bashrc
EOF

$GENKEY = <<EOF
ssh-keygen -t rsa -b 4096 -f "/root/.ssh/provisioned_id_rsa.`openssl rand -hex 12`" -q -N ""
ssh-keygen -t rsa -b 4096 -f "/home/vagrant/.ssh/provisioned_id_rsa.`openssl rand -hex 12`" -q -N ""
EOF

### WRITE /ETC/HOSTS VERY EARLY
$FIRST = <<EOF
echo -e '#{ETC_HOSTS}' >> /etc/hosts \
   && echo -e 'added to /etc/hosts: #{ETC_HOSTS}'
sudo apt-get -y -qq update && sudo apt-get -y -qq upgrade
   #{PYTHON}
EOF

$LAST = $ETC_INIT_SYNCHOSTS + $BIN_RUNSSH #+ <<-EOF
   #{BASHRC}  >> /etc/bash.bashrc
#EOF

$ADHOC = ""

### MASTER ###
   config.vm.define "#{MASTER}" do |subconfig|

# WRITES:   ~vagrant/create_k8s_cluster.sh
      $CREATE_CLUSTER = <<-EOF
echo '#!/bin/bash

#DO AS VAGRANT
#systemctl status docker
#systemctl status kubelet
#if [ ! -f /etc/init/docker.conf ]; then echo /etc/init/docker.conf not found; fi
#sudo kubeadm reset -f && sudo rm -rf ~vagrant/.kube

kubeadm init --apiserver-advertise-address=#{mstr_ip_pool[0]} \
   --pod-network-cidr=#{POD_NETWORK}/#{NETMASK} >> cluster_initialized.txt 2>&1 \
\
   && mkdir /home/vagrant/.kube \
   && cp /etc/kubernetes/admin.conf /home/vagrant/.kube/config \
   && chown -R vagrant:vagrant /home/vagrant/.kube \
   && su - vagrant -c "kubectl create -f https://docs.projectcalico.org/v3.9/manifests/calico.yaml" \
   && kubeadm token create --print-join-command > /joincluster.sh' > /root/create_k8s_cluster.sh
/bin/bash /root/create_k8s_cluster.sh > /root/create_k8s_cluster.log 2>&1
EOF
      $HOOK = $ETC_INITD_NTPSYNC + <<-EOF
         #{NTP}
         #{DOCKER}
         #{DOCKERCOMPOSE}
         #{K8S}
         #{KUBECTL}
echo 'echo "kubectl get nodes"' >> ~vagrant/.bashrc
echo 'echo "kubectl get all --all-namespaces"' >> ~vagrant/.bashrc
echo 'echo "kubectl get pods -n kube-system"' >> ~vagrant/.bashrc
      EOF
      subconfig.vm.box = "#{IMAGE}"
      subconfig.vm.hostname = "#{MASTER}.#{PURPOSE}.#{LIFECYCLE}.#{DOMAIN}"
      subconfig.vm.provider "#{PROVIDER}" do |v|
         v.name = "#{VM_NAME_MASTER}"
         v.memory = 2048
         v.cpus = 2
      end
      subconfig.vm.provision "AdHoc", type: "shell", run: "never", name: "AdHoc", inline: $ADHOC
      subconfig.vm.provision "First", type: "shell", run: "once", name: "First", inline: $FIRST
      subconfig.vm.provision "GenKey", type: "shell", run: "once", name: "GenKey", inline: $GENKEY
      subconfig.vm.provision "#{MASTER}", type: "shell", run: "once", name: "#{MASTER}", path: "#{MASTER_SCRIPT}"
      subconfig.vm.provision "RootKey", type: "shell", run: "once", name: "RootKey", path: "#{ROOT_KEY_SCRIPT}"
      subconfig.vm.provision "VagrantKey", type: "shell", run: "once", name: "VagrantKey", path: "#{VAGRANT_KEY_SCRIPT}"
      subconfig.vm.provision "Hook", type: "shell", run: "once", name: "Hook", inline: $HOOK
      subconfig.vm.provision "Cluster", type: "shell", run: "once", name: "Cluster", inline: $CREATE_CLUSTER
      subconfig.vm.provision "Last", type: "shell", run: "once", name: "Last", inline: $LAST
      subconfig.vm.provision "shell", type: "shell", run: "always", name:"provisioned_at", inline: <<-EOF
            date >> /etc/vagrant_provisioned_at
            EOF
      PORT = 2300
      subconfig.vm.network "forwarded_port", guest: 22, host: PORT, id: "ssh", auto_correct: ! "#{TEST}".empty?
      subconfig.vm.network "private_network", ip: host_ip_pool[1], netmask: NETMASK, virtualbox__intnet: "anytownusa"
   end
### MASTER ###

### NODES ###
   (1..POD_NODE_CT).each do |i|
      config.vm.define "#{NODE}#{i}" do |subconfig|
         $HOOK = <<-EOF
            #{DOCKER}
            #{K8S}
         EOF

# WRITES:   /root/join_k8s_cluster.sh
         $JOIN = <<-EOF
echo '#!/bin/bash
scp -o StrictHostKeyChecking=no "#{MASTER}.#{HOSTNAME_SUFFIX}":/joincluster.sh /joincluster.sh
/bin/bash /joincluster.sh' > /root/join_k8s_cluster.sh
/bin/bash /root/join_k8s_cluster.sh > /root/join_k8s_cluster.log 2>&1
EOF
         subconfig.vm.box = "#{IMAGE}"
         subconfig.vm.hostname = "#{NODE}#{i}.#{PURPOSE}.#{LIFECYCLE}.#{DOMAIN}"
         subconfig.vm.provider "#{PROVIDER}" do |v|
            v.name = "#{VM_NAME_NODE}#{i}"
            v.memory = 1024
            v.cpus = 2
         end
         subconfig.vm.provision "AdHoc", type: "shell", run: "never", name: "AdHoc", inline: $ADHOC
         subconfig.vm.provision "First", type: "shell", run: "once", name: "First", inline: $FIRST
         subconfig.vm.provision "GenKey", type: "shell", run: "once", name: "GenKey", inline: $GENKEY
         subconfig.vm.provision "#{NODE}#{i}", type: "shell", run: "once", name: "#{NODE}#{i}", path: "#{NODE_SCRIPT}"
         subconfig.vm.provision "RootKey", type: "shell", run: "once", name: "RootKey", path: "#{ROOT_KEY_SCRIPT}"
         subconfig.vm.provision "VagrantKey", type: "shell", run: "once", name: "VagrantKey", path: "#{VAGRANT_KEY_SCRIPT}"
         subconfig.vm.provision "Hook", type: "shell", run: "once", name: "Hook", inline: $HOOK
         subconfig.vm.provision "Join", type: "shell", run: "once", name: "Join", inline: $JOIN
         subconfig.vm.provision "Last", type: "shell", run: "once", name: "Last", inline: $LAST
         subconfig.vm.provision "shell", type: "shell", run: "always", name:"provisioned_at", inline: <<-EOF
               date >> /etc/vagrant_provisioned_at
               EOF
         PORT = 2300 + i
         subconfig.vm.network "forwarded_port", guest: 22, host: PORT, id: "ssh", auto_correct: ! "#{TEST}".empty?
         ndx = i - 1
         subconfig.vm.network "private_network", ip: pod_ip_pool[ndx], netmask: NETMASK, virtualbox__intnet: "anytownusa"
      end
   end
### NODES ###

### CONTROLER ###
   config.vm.define "#{CONTROLER}" do |subconfig|
      $HOOK = $ETC_INITD_NTPSYNC + <<-EOF
         #{NTP}
         #{AWSCLI}
      EOF
      subconfig.vm.box = "#{IMAGE}"
      subconfig.vm.hostname = "#{CONTROLER}.#{PURPOSE}.#{LIFECYCLE}.#{DOMAIN}"
      subconfig.vm.provider "#{PROVIDER}" do |v|
         v.name = "#{VM_NAME_CONTROLER}"
         v.memory = 1024
      end
      subconfig.vm.provision "AdHoc", type: "shell", run: "never", name: "AdHoc", inline: $ADHOC
      subconfig.vm.provision "First", type: "shell", run: "once", name: "First", inline: $FIRST
      subconfig.vm.provision "GenKey", type: "shell", run: "once", name: "GenKey", inline: $GENKEY
      subconfig.vm.provision "#{CONTROLER}", type: "shell", run: "once", name: "#{CONTROLER}", path: "#{CONTROLER_SCRIPT}"
      subconfig.vm.provision "RootKey", type: "shell", run: "once", name: "RootKey", path: "#{ROOT_KEY_SCRIPT}"
      subconfig.vm.provision "VagrantKey", type: "shell", run: "once", name: "VagrantKey", path: "#{VAGRANT_KEY_SCRIPT}"
      subconfig.vm.provision "Hook", type: "shell", run: "once", name: "Hook", inline: $HOOK
      subconfig.vm.provision "Last", type: "shell", run: "once", name: "Last", inline: $LAST
      subconfig.vm.provision "shell", type: "shell", run: "always", name:"provisioned_at", inline: <<-EOF
            date >> /etc/vagrant_provisioned_at
            EOF
      PORT = 2400
      subconfig.vm.network "forwarded_port", guest: 22, host: PORT, id: "ssh", auto_correct: ! "#{TEST}".empty?
      subconfig.vm.network "private_network", ip: host_ip_pool[0], netmask: NETMASK, virtualbox__intnet: "anytownusa"
      #subconfig.vm.network "forwarded_port", guest: 3000, host: 3000
   end
### CONTROLER ###

  # Disable automatic box update checking. If you disable this, then
  # boxes will only be checked for updates when the user runs
  # `vagrant box outdated`. This is not recommended.
  # config.vm.box_check_update = false

end
### END Vagrant.configure ###
MSG = "%%%%% %%%%% %%%%% %%%%% %%%%% %%%%% %%%%% %%%%% %%%%% *****"
def msg(message)
   return "#{MSG} #{message}"
end

NTP = 'echo ' + msg("Installing NTP")+'
sudo apt-get -y -qq install ntp ntpdate ntpstat \
   && if sudo service ntp status > /dev/null; then sudo service ntp stop; fi \
   && echo "syncing NTP with time.nist.gov..." \
   && sudo ntpdate time.nist.gov && sudo service ntp start \
   && ntp_tries=10 && ntp_delay_seconds=3 && i=0 \
   && while ! ntpstat; do sleep ${ntp_delay_seconds} && i=`expr ${i} + 1` \
   &&    if [ ${i} -ge ${ntp_tries} ]; \
            then echo -n "NTP:" && echo bailing && break; fi; done'

PYTHON = 'echo ' + msg("Installing Python")+'
sudo apt-get -y -qq install python3 \
   && sudo update-alternatives --install \
         /usr/bin/python python /usr/bin/python3 1'

ANSIBLE = 'echo ' + msg("Installing Ansible")+'
   sudo apt-add-repository --yes --update ppa:ansible/ansible\
   && sudo apt-get -y install ansible'

AWSCLI = 'echo ' + msg("Installing AWS CLI")+'
if ! command -v curl > /dev/null; then sudo apt-get -y -qq install curl; fi
if ! command -v unzip > /dev/null; then sudo apt-get -y -qq install unzip; fi
curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip\
   && if ! command -v aws > /dev/null; then unzip -q awscliv2.zip && sudo ./aws/install; else sudo ./aws/install --update; fi'

DOCKER = 'echo ' + msg("Installing Docker")+'
if ! command -v curl > /dev/null; then sudo apt-get -y -qq install curl; fi
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key --keyring /etc/apt/trusted.gpg.d/docker.gpg add - \
&& sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" \
&& sudo apt-get -y -qq update && sudo apt-get -y -qq upgrade \
&& echo "12 4" | sudo apt-get -y -qq install software-properties-common \
&& sudo apt-get -y -qq install \
   apt-transport-https \
   ca-certificates \
   gnupg2 \
   gnupg-agent \
   docker-ce \
   docker-ce-cli \
   containerd.io
systemctl enable docker
systemctl start docker
usermod -aG docker vagrant
'

DOCKERCOMPOSE = 'echo ' + msg("Installing Docker Compose")+'
sudo curl -sL https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose \
      && sudo chmod +x /usr/local/bin/docker-compose'

K8S = 'echo ' + msg("Installing k8s base")+'
cat >>/etc/sysctl.d/kubernetes.conf<<EOF &&
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sysctl --system >/dev/null 2>&1

sed -i "/swap/d" /etc/fstab && swapoff -a \
\
&& echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list \
&& curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - \
&& sudo apt-get -y -qq update && sudo apt-get -y -qq upgrade \
&& sudo apt-get -y -qq install \
   kubelet \
   kubeadm \
   kubernetes-cni \
   kubectl

systemctl enable kubelet >/dev/null 2>&1
systemctl start kubelet >/dev/null 2>&1

sed -i "s/#PermitRootLogin prohibit-password/PermitRootLogin yes/" /etc/ssh/sshd_config
systemctl restart sshd
'

KUBECTL = 'echo ' + msg("Installing kubectl")+'
sudo apt-get -y -qq install \
   kubectl'

BASHRC = "echo '
function color  { echo -n \"\$(tput setaf $1;tput setab $2)${3}$(tput sgr 0) \"; }
function green  { color 4 2 \"${*}\"; }
function yellow { color 0 3 \"${*}\"; }
function red    { color 0 1 \"${*}\"; }
function blue   { color 6 4 \"${*}\"; }
function cyan   { color 4 6 \"${*}\"; }
function grey   { color 0 7 \"${*}\"; }
function pass   { echo \"$(green PASS: ${*})\"; echo; }
function warn   { echo \"$(yellow PASS: ${*})\"; echo; }
function fail   { echo \"$(red FAIL: ${*})\"; echo; }
function info   { echo \"$(grey INFO: ${*})\"; echo; }
grep \"DISTRIB_DESCRIPTION\" /etc/lsb-release

if systemctl --all --type service | grep -q ntp.service; then
   echo \"NTP sync...\"
   if command -v ntpstat > /dev/null 2>&1; then
      ntp_tries=15 && ntp_delay_seconds=2 && i=0
      while ! ntpstat 2> /dev/null
        do sleep \${ntp_delay_seconds} && i=\`expr \${i} + 1\`
        if [ \${i} -ge \${ntp_tries} ]
          then yellow \"NTP:\" && echo bailing && break
        fi
      done
      if ntpstat > /dev/null 2>&1
         then green \"NTP Synchronization Status:\" && ntpstat
         else red \"NTP:\" && echo \"not synchronized\"
      fi
   fi
fi

if command -v kubelet > /dev/null 2>&1; then cyan \"kubelet:\" && kubelet --version; else yellow \"No kubelet\"; echo; fi;
if command -v kubectl > /dev/null 2>&1; then cyan \"kubectl:\" && kubectl version --short --client; else yellow \"No kubectl\"; echo; fi;
if command -v kubeadm > /dev/null 2>&1; then cyan \"kubeadm:\" && kubeadm version --output short; else yellow \"No kubeadm\"; echo; fi;
if command -v helm > /dev/null 2>&1; then cyan \"helm:\" && helm version --short; else yellow \"No helm\"; echo; fi;
if command -v docker > /dev/null 2>&1; then cyan \"docker:\" && docker --version && sudo docker run --rm hello-world 2> /dev/null | grep -o \"Hello from Docker!\"; else yellow \"No Docker\"; echo; fi;
if command -v docker-compose > /dev/null 2>&1; then cyan \"Docker Compose:\" && docker-compose --version; else yellow \"No Docker Compose\"; echo; fi;
if command -v aws > /dev/null 2>&1; then cyan \"AWS CLI:\" && /usr/local/bin/aws --version; else yellow \"No AWS CLI\"; echo; fi;
ip route
'"

#ssh master.k8s 'x=`grep -n DISTRIB_DESCRIPTION ~/.bashrc| cut -f1 -d:` && y=`cat ~/.bashrc|wc -l` && z=`expr $y - $x + 1` && cp -p ~/.bashrc ~/.bashrc.bak && cat>~/.bashrc<<<`head -n -${z} ~/.bashrc.bak`'
#run-ssh 'hostname && x=`grep -n DISTRIB_DESCRIPTION ~/.bashrc| cut -f1 -d:` && y=`cat ~/.bashrc|wc -l` && z=`expr $y - $x + 1` && cp -p ~/.bashrc ~/.bashrc.bak && cat>~/.bashrc<<<`head -n -${z} ~/.bashrc.bak`'
#run-ssh 'hostname && x=`grep -n DISTRIB_DESCRIPTION ~vagrant/.bashrc| cut -f1 -d:` && y=`cat ~vagrant/.bashrc|wc -l` && z=`expr $y - $x + 1` && cp -p ~vagrant/.bashrc ~vagrant/.bashrc.bak && cat>~vagrant/.bashrc<<<`head -n -${z} ~vagrant/.bashrc.bak`'

#s="" && f="" && sed -i 's/128\.1\.[0,1]/192\.168\.0/' ${f} && x=`grep -n ${s} ${f}| cut -f1 -d:` && y=`cat ${f}|wc -l` && z=`expr $y - $x + 1` && cp -p ${f} ${f}.bak && cat>${f}<<<`head -n -${z} ${f}.bak`

### REMOVE ALL LINES BELOW ${s} FROM /ETC/HOSTS
#s="127.0.2.1" && run-ssh 'hostname && x=`grep -n "127.0.2.1" /etc/hosts | cut -f1 -d:` && y=`cat /etc/hosts|wc -l` && z=`expr $y - $x` && cp -p /etc/hosts /etc/hosts.bak && cat>/etc/hosts<<<`head -n -${z} /etc/hosts.bak` && cat /etc/hosts'

#s="127.0.2.1" && x=`grep -n "${s}" /etc/hosts | cut -f1 -d:` && y=`cat /etc/hosts|wc -l` && z=`expr $y - $x` && cp -p /etc/hosts /etc/hosts.bak && cat>/etc/hosts<<<`head -n -${z} /etc/hosts.bak` && cat /etc/hosts


#// MASTER AS VAGRANT
#sudo kubeadm init --apiserver-advertise-address=128.1.0.20 --pod-network-cidr=128.1.0.0/20 >> cluster_initialized.txt
#mkdir -p $HOME/.kube
#sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
#sudo chown $(id -u):$(id -g) $HOME/.kube/config
#kubectl create -f https://docs.projectcalico.org/v3.9/manifests/calico.yaml
#kubeadm token create --print-join-command > ./joincluster.sh
#sudo mv ./joincluster.sh /joincluster.sh

#// WORKER AS ROOT
#apt-get  install -y sshpass >/dev/null 2>&1
#scp -o StrictHostKeyChecking=no master.k8s-cluster.dev.anytown.usa:/joincluster.sh /joincluster.sh

# // KUBECTL COMMANDS
#watch kubectl get nodes
#watch kubectl get all --all-namespaces
#watch kubectl get pods -n kube-system

#kubectl get pods -n calico-system
#watch kubectl get pods -n calico-system
